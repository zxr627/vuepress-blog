import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o as a}from"./app-244kRLAi.js";const l={};function t(r,e){return a(),i("div",null,[...e[0]||(e[0]=[n(`<h1 id="双token鉴权机制详解" tabindex="-1"><a class="header-anchor" href="#双token鉴权机制详解"><span>双Token鉴权机制详解</span></a></h1><p>在现代 Web 项目中，<strong>Token 鉴权机制</strong> 已经逐渐取代了传统的 Session 认证方式。<br> 本文将完整介绍一套基于 <strong>Access Token + Refresh Token</strong> 的登录鉴权体系，<br> 包括前端与后端的存储、交互、刷新逻辑，以及安全设计思路。</p><hr><h2 id="🧩-一、整体思路概览" tabindex="-1"><a class="header-anchor" href="#🧩-一、整体思路概览"><span>🧩 一、整体思路概览</span></a></h2><blockquote><p>核心思想：<br> 使用短期凭证 <code>accessToken</code> 访问接口，使用长期凭证 <code>refreshToken</code> 续签新的 accessToken。</p></blockquote><ul><li><code>accessToken</code>：访问令牌，有效期短（例如 2 小时），每次请求都携带。</li><li><code>refreshToken</code>：刷新令牌，有效期长（例如 7 天），仅在 accessToken 过期时使用。</li><li>后端将 refreshToken 存储在 Redis 中，用于校验和失效控制。</li><li>前端将 accessToken 存储在浏览器中，用于每次接口访问。</li></ul><hr><h2 id="🚪-二、登录阶段-token-生成与存储" tabindex="-1"><a class="header-anchor" href="#🚪-二、登录阶段-token-生成与存储"><span>🚪 二、登录阶段（Token 生成与存储）</span></a></h2><h3 id="_1️⃣-前端行为" tabindex="-1"><a class="header-anchor" href="#_1️⃣-前端行为"><span>1️⃣ 前端行为</span></a></h3><p>用户在登录页输入手机号和验证码（或账号密码），向后端发起登录请求：</p><p>该请求不携带任何 Token。</p><h3 id="_2️⃣-后端行为" tabindex="-1"><a class="header-anchor" href="#_2️⃣-后端行为"><span>2️⃣ 后端行为</span></a></h3><p>后端校验登录信息成功后，生成：</p><ul><li><code>accessToken</code>：有效期 2 小时；</li><li><code>refreshToken</code>：有效期 7 天；</li></ul><p>并执行以下操作：</p><ul><li>将 refreshToken 存入 Redis：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>key: refresh_token:{userId}</span></span>
<span class="line"><span>value: &lt;refreshToken&gt;</span></span>
<span class="line"><span>TTL: 7 days</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>返回给前端：</li></ul><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;accessToken&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;xxxxxx&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;refreshToken&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;yyyyyy&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3️⃣-前端存储" tabindex="-1"><a class="header-anchor" href="#_3️⃣-前端存储"><span>3️⃣ 前端存储</span></a></h3><p>前端拿到 Token 后：</p><ul><li>将 <strong>accessToken</strong> 加密存入 <code>localStorage</code> 或 <code>sessionStorage</code>；</li><li>将 <strong>refreshToken</strong> 临时存储在内存或会话存储中；</li><li>之后每次请求接口时自动携带：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Authorization: Bearer &lt;accessToken&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="🌐-三、接口请求阶段-正常访问" tabindex="-1"><a class="header-anchor" href="#🌐-三、接口请求阶段-正常访问"><span>🌐 三、接口请求阶段（正常访问）</span></a></h2><h3 id="_1️⃣-前端行为-1" tabindex="-1"><a class="header-anchor" href="#_1️⃣-前端行为-1"><span>1️⃣ 前端行为</span></a></h3><p>用户在操作页面时发起各种 API 请求，<br> 请求头中会自动附带 accessToken：</p><h3 id="_2️⃣-后端行为-1" tabindex="-1"><a class="header-anchor" href="#_2️⃣-后端行为-1"><span>2️⃣ 后端行为</span></a></h3><p>后端拦截请求，验证 accessToken：</p><table><thead><tr><th>情况</th><th>处理方式</th></tr></thead><tbody><tr><td>Token 有效</td><td>放行请求</td></tr><tr><td>Token 无效（签名错误）</td><td>返回 <code>401 Unauthorized</code></td></tr><tr><td>Token 过期</td><td>返回特定错误码，如：<code>40101</code></td></tr></tbody></table><hr><h2 id="🔁-四、token-刷新阶段-accesstoken-过期" tabindex="-1"><a class="header-anchor" href="#🔁-四、token-刷新阶段-accesstoken-过期"><span>🔁 四、Token 刷新阶段（accessToken 过期）</span></a></h2><p>当 accessToken 过期时，系统不要求用户重新登录。<br> 流程如下：</p><h3 id="_1️⃣-前端检测" tabindex="-1"><a class="header-anchor" href="#_1️⃣-前端检测"><span>1️⃣ 前端检测</span></a></h3><p>在 Axios 响应拦截器中检测到响应状态为 <code>40101</code>（accessToken 过期），<br> 则自动调用刷新接口：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">POST</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">api</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">refresh</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  &quot;refreshToken&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;yyyyyy&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2️⃣-后端处理" tabindex="-1"><a class="header-anchor" href="#_2️⃣-后端处理"><span>2️⃣ 后端处理</span></a></h3><p>后端接收到 refreshToken 后：</p><ol><li>从 Redis 中查找 <code>refresh_token:{userId}</code>；</li><li>若存在且匹配，则说明 refreshToken 有效；</li><li>生成新的 accessToken；</li><li>更新 Redis 中的存储（可选择刷新 refreshToken 一并更新）；</li><li>返回新的 accessToken 给前端。</li></ol><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;accessToken&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;new-access-token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;refreshToken&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;new-refresh-token&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3️⃣-前端更新" tabindex="-1"><a class="header-anchor" href="#_3️⃣-前端更新"><span>3️⃣ 前端更新</span></a></h3><p>前端拿到新的 accessToken 后：</p><ul><li>更新本地存储；</li><li>重新发起原本失败的请求；</li><li>用户体验无感知。</li></ul><hr><h2 id="⚠️-五、刷新失败-refreshtoken-过期" tabindex="-1"><a class="header-anchor" href="#⚠️-五、刷新失败-refreshtoken-过期"><span>⚠️ 五、刷新失败（refreshToken 过期）</span></a></h2><p>当 refreshToken 也过期时，系统不再允许自动续期。</p><h3 id="_1️⃣-后端行为" tabindex="-1"><a class="header-anchor" href="#_1️⃣-后端行为"><span>1️⃣ 后端行为</span></a></h3><p>后端校验 Redis 中的 refreshToken 时发现：</p><ul><li>key 不存在；</li><li>或者已超出有效期；</li><li>或者值不匹配（被强制下线）。</li></ul><p>此时返回：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;code&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">401</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;msg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;refreshToken已过期，请重新登录&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2️⃣-前端行为" tabindex="-1"><a class="header-anchor" href="#_2️⃣-前端行为"><span>2️⃣ 前端行为</span></a></h3><p>响应拦截器捕获到该状态后：</p><ul><li>清空本地 Token；</li><li>跳转到登录页；</li><li>提示用户重新登录。</li></ul><hr><h2 id="🚪-六、退出登录或强制下线" tabindex="-1"><a class="header-anchor" href="#🚪-六、退出登录或强制下线"><span>🚪 六、退出登录或强制下线</span></a></h2><h3 id="前端" tabindex="-1"><a class="header-anchor" href="#前端"><span>前端：</span></a></h3><ul><li>调用登出接口 <code>/logout</code>；</li><li>清空本地存储（accessToken、refreshToken）。</li></ul><h3 id="后端" tabindex="-1"><a class="header-anchor" href="#后端"><span>后端：</span></a></h3><ul><li>删除 Redis 中对应的 refreshToken；</li><li>若用户尝试携带旧的 accessToken 调用接口，会直接鉴权失败。</li></ul><hr><h2 id="🧠-七、token-生命周期示意图" tabindex="-1"><a class="header-anchor" href="#🧠-七、token-生命周期示意图"><span>🧠 七、Token 生命周期示意图</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>[ 登录 ]</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>生成 accessToken(2h) &amp; refreshToken(7d)</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>[ 正常请求 - 带 accessToken ]</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>(2h 到期)</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>[ 调用 refreshToken 刷新 Token ]</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>→ refreshToken 有效 → 获取新 accessToken → 继续使用</span></span>
<span class="line"><span>→ refreshToken 失效 → 返回登录页重新登录</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="🔒-八、安全建议" tabindex="-1"><a class="header-anchor" href="#🔒-八、安全建议"><span>🔒 八、安全建议</span></a></h2><table><thead><tr><th>建议</th><th>说明</th></tr></thead><tbody><tr><td>✅ HTTPS</td><td>所有请求必须走 HTTPS</td></tr><tr><td>✅ refreshToken 存储</td><td>建议仅存于内存或 Session，而非 localStorage</td></tr><tr><td>✅ 登出时清理</td><td>确保 Redis 和前端同时清空 Token</td></tr><tr><td>✅ Token 绑定</td><td>可在 Token 中绑定 userId、设备标识、IP 等信息</td></tr><tr><td>✅ 轮换策略</td><td>每次刷新都生成新的 refreshToken，提升安全性</td></tr></tbody></table><hr><h2 id="🧾-九、配置参数推荐" tabindex="-1"><a class="header-anchor" href="#🧾-九、配置参数推荐"><span>🧾 九、配置参数推荐</span></a></h2><table><thead><tr><th>项目</th><th>说明</th><th>建议值</th></tr></thead><tbody><tr><td>Access Token 有效期</td><td>用户正常使用的时间段</td><td>2 小时</td></tr><tr><td>Refresh Token 有效期</td><td>用于续签的最长时间</td><td>7 天</td></tr><tr><td>Redis Key 命名</td><td>防止冲突</td><td><code>refresh_token:{userId}</code></td></tr><tr><td>Token 存储位置</td><td>前端</td><td>localStorage（加密后）</td></tr><tr><td>Token 存储位置</td><td>后端</td><td>Redis（带 TTL）</td></tr></tbody></table><hr><h2 id="🧭-十、总结" tabindex="-1"><a class="header-anchor" href="#🧭-十、总结"><span>🧭 十、总结</span></a></h2><p>整个 Token 鉴权体系遵循以下原则：</p><blockquote><p>短期凭证（Access Token）负责访问，<br> 长期凭证（Refresh Token）负责续命。</p><p>后端用 Redis 控制刷新权限，<br> 前端用拦截器实现自动续签。</p><p>当 Refresh Token 过期或被删除时，<br> 用户必须重新登录，安全与体验兼得。</p></blockquote><hr>`,74)])])}const o=s(l,[["render",t],["__file","tokenRefreshToken.html.vue"]]),k=JSON.parse(`{"path":"/Database/NoSQL/tokenRefreshToken.html","title":"双Token鉴权机制详解","lang":"zh-CN","frontmatter":{"order":3,"date":"2025-10-16T00:00:00.000Z","category":["Redis"],"description":"双Token鉴权机制详解 在现代 Web 项目中，Token 鉴权机制 已经逐渐取代了传统的 Session 认证方式。 本文将完整介绍一套基于 Access Token + Refresh Token 的登录鉴权体系， 包括前端与后端的存储、交互、刷新逻辑，以及安全设计思路。 🧩 一、整体思路概览 核心思想： 使用短期凭证 accessToken ...","head":[["meta",{"property":"og:url","content":"https://zxroo.top/Database/NoSQL/tokenRefreshToken.html"}],["meta",{"property":"og:site_name","content":"Zxr's Blog"}],["meta",{"property":"og:title","content":"双Token鉴权机制详解"}],["meta",{"property":"og:description","content":"双Token鉴权机制详解 在现代 Web 项目中，Token 鉴权机制 已经逐渐取代了传统的 Session 认证方式。 本文将完整介绍一套基于 Access Token + Refresh Token 的登录鉴权体系， 包括前端与后端的存储、交互、刷新逻辑，以及安全设计思路。 🧩 一、整体思路概览 核心思想： 使用短期凭证 accessToken ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-16T10:02:44.000Z"}],["meta",{"property":"article:published_time","content":"2025-10-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-16T10:02:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"双Token鉴权机制详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-16T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-16T10:02:44.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"🧩 一、整体思路概览","slug":"🧩-一、整体思路概览","link":"#🧩-一、整体思路概览","children":[]},{"level":2,"title":"🚪 二、登录阶段（Token 生成与存储）","slug":"🚪-二、登录阶段-token-生成与存储","link":"#🚪-二、登录阶段-token-生成与存储","children":[{"level":3,"title":"1️⃣ 前端行为","slug":"_1️⃣-前端行为","link":"#_1️⃣-前端行为","children":[]},{"level":3,"title":"2️⃣ 后端行为","slug":"_2️⃣-后端行为","link":"#_2️⃣-后端行为","children":[]},{"level":3,"title":"3️⃣ 前端存储","slug":"_3️⃣-前端存储","link":"#_3️⃣-前端存储","children":[]}]},{"level":2,"title":"🌐 三、接口请求阶段（正常访问）","slug":"🌐-三、接口请求阶段-正常访问","link":"#🌐-三、接口请求阶段-正常访问","children":[{"level":3,"title":"1️⃣ 前端行为","slug":"_1️⃣-前端行为-1","link":"#_1️⃣-前端行为-1","children":[]},{"level":3,"title":"2️⃣ 后端行为","slug":"_2️⃣-后端行为-1","link":"#_2️⃣-后端行为-1","children":[]}]},{"level":2,"title":"🔁 四、Token 刷新阶段（accessToken 过期）","slug":"🔁-四、token-刷新阶段-accesstoken-过期","link":"#🔁-四、token-刷新阶段-accesstoken-过期","children":[{"level":3,"title":"1️⃣ 前端检测","slug":"_1️⃣-前端检测","link":"#_1️⃣-前端检测","children":[]},{"level":3,"title":"2️⃣ 后端处理","slug":"_2️⃣-后端处理","link":"#_2️⃣-后端处理","children":[]},{"level":3,"title":"3️⃣ 前端更新","slug":"_3️⃣-前端更新","link":"#_3️⃣-前端更新","children":[]}]},{"level":2,"title":"⚠️ 五、刷新失败（refreshToken 过期）","slug":"⚠️-五、刷新失败-refreshtoken-过期","link":"#⚠️-五、刷新失败-refreshtoken-过期","children":[{"level":3,"title":"1️⃣ 后端行为","slug":"_1️⃣-后端行为","link":"#_1️⃣-后端行为","children":[]},{"level":3,"title":"2️⃣ 前端行为","slug":"_2️⃣-前端行为","link":"#_2️⃣-前端行为","children":[]}]},{"level":2,"title":"🚪 六、退出登录或强制下线","slug":"🚪-六、退出登录或强制下线","link":"#🚪-六、退出登录或强制下线","children":[{"level":3,"title":"前端：","slug":"前端","link":"#前端","children":[]},{"level":3,"title":"后端：","slug":"后端","link":"#后端","children":[]}]},{"level":2,"title":"🧠 七、Token 生命周期示意图","slug":"🧠-七、token-生命周期示意图","link":"#🧠-七、token-生命周期示意图","children":[]},{"level":2,"title":"🔒 八、安全建议","slug":"🔒-八、安全建议","link":"#🔒-八、安全建议","children":[]},{"level":2,"title":"🧾 九、配置参数推荐","slug":"🧾-九、配置参数推荐","link":"#🧾-九、配置参数推荐","children":[]},{"level":2,"title":"🧭 十、总结","slug":"🧭-十、总结","link":"#🧭-十、总结","children":[]}],"git":{"createdTime":1760608964000,"updatedTime":1760608964000,"contributors":[{"name":"zhaoxinrong","email":"“zhaoxr@cwanwu.com”","commits":1}]},"readingTime":{"minutes":3.72,"words":1116},"filePathRelative":"Database/NoSQL/tokenRefreshToken.md","localizedDate":"2025年10月16日","excerpt":"","autoDesc":true}`);export{o as comp,k as data};
